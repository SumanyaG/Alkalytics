\documentclass[12pt, titlepage]{article}

\usepackage[margin=1in]{geometry}
\usepackage[round]{natbib}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{float}
\usepackage{hyperref}
\usepackage{listings}

\hypersetup{
    colorlinks,
    citecolor=blue,
    filecolor=black,
    linkcolor=red,
    urlcolor=blue
}

\input{../../Comments}
\input{../../Common}

\newcounter{acnum}
\newcommand{\actheacnum}{AC\theacnum}
\newcommand{\acref}[1]{AC\ref{#1}}

\newcounter{ucnum}
\newcommand{\uctheucnum}{UC\theucnum}
\newcommand{\uref}[1]{UC\ref{#1}}

\newcounter{mnum}
\newcommand{\mthemnum}{M\themnum}
\newcommand{\mref}[1]{M\ref{#1}}

\begin{document}

\title{Module Guide for \progname{}} 
\author{\authname}
\date{\today}

\maketitle

\pagenumbering{roman}

\section{Revision History}

\begin{tabularx}{\textwidth}{p{3cm}p{2cm}X}
\toprule {\bf Date} & {\bf Version} & {\bf Notes}\\
\midrule
11 Janury 2025 & 1.0 & Added initial content for Rev 0.\\
\bottomrule
\end{tabularx}
\\
\newline \newline
\emph{\textbf{Note:}} Please note that our team has adapted and extended this
Module Guide document to include the contents of an MIS or other such document.
For this reason, only one design document has been submitted.
\newpage

\section{Reference Material}

This section records information for easy reference.

\subsection{Abbreviations and Acronyms}

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{l l} 
  \toprule		
  \textbf{symbol} & \textbf{description}\\
  \midrule 
  AC & Anticipated Change\\
  API & Application Programming Interface\\
  CSV & Comma Separated Values\\
  DAG & Directed Acyclic Graph \\
  JSON & JavaScript Object Notation\\
  KPI & Key Performance Indicator\\
  M & Module \\
  MG & Module Guide \\
  MIS & Module Interface Specification\\
  OS & Operating System \\
  R & Requirement\\
  SC & Scientific Computing \\
  SRS & Software Requirements Specification\\
  \progname & Explanation of program name\\
  UC & Unlikely Change \\
  UI & User Interface\\
  XML & Extensible Markup Language\\
  \bottomrule
\end{tabular}\\

\subsection{Notation}

\newpage

\tableofcontents

\listoftables

\listoffigures

\newpage

\pagenumbering{arabic}

\section{Introduction}

\subsection{Summary}
Alkalytics is a project designed to provide a scalable data management and analysis
solution for ocean alkalinity research, in particular by streamlining the data 
organization, querying, and visualization processes. Through its various modules, 
the primary goal of the system is to offer a comprehensive solution for data 
ingestion, processing and reporting  while maintaining adaptability to future 
changes.\\
\newline
Each functional component is developed as an independent module to encapsulate 
specific responsibilities, minimize dependencies, and promote information
hiding. This modular approach, advocated for widely in the software sector, not only
simplifies development and testing but also allows the system to accommodate evolving
user requirements and technology upgrades.

\subsection{Purpose}
This Module Guide (MG) has been written to serve as a roadmap for the Alkalytics system,
detailing its structure, functionality, and the relationships between its components.
It provides clarity on how the system meets the requirements outlined in the 
\href{https://github.com/SumanyaG/Alkalytics/blob/main/docs/SRS/SRS.pdf}{Software Requirements Specification (SRS)}
and supports the following stakeholders:
\begin{itemize}
  \item \textbf{New Developers}: To understand the modular architecture and ensure
  consistent implementation.
  \item \textbf{Maintainers}: To efficiently identify, update, or rewrite modules as needed.
  \item \textbf{Designers}: To validate the system's feasibility, flexibility, and alignment
  with project goals. 
\end{itemize}

\section{Anticipated and Unlikely Changes} \label{SecChange}

This section identifies potential changes to the system and classifies them into
two categories: anticipated changes (AC) as listed in section \ref{SecAchange} and
unlikely changes (UC) as listed in section \ref{SecUchange}. AC represent decisions 
that have been encapsulated within specific modules to minimize the impact of 
modifications while UC are those that, while possible, are fixed at the system 
architecture stage to reduce complexity.

\subsection{Anticipated Changes} \label{SecAchange}

Anticipated changes are the source of the information that is to be hidden
inside the modules. Ideally, changing one of the anticipated changes will only
require changing the one module that hides the associated decision. These changes
are encapsulated within specific modules to ensure the system's adaptability.

\begin{description}
  \item[\refstepcounter{acnum} \actheacnum \label{acHardware}:] \textbf{Hardware Configuration} - 
  The software may need to run on a different hardware platform like a server or on a 
  cloud solution. Changes in hardware specifications will primarily affect the Hardware-Hiding 
  Module, isolating their imoact.
  
  \item[\refstepcounter{acnum} \actheacnum \label{acProcessing}:] \textbf{Data Processing Algorithms} - 
  Changes in analytical techniques along with advances in the machine learning space would
  introduce the need for new statistical models. These changes would be encapsulated in the
  Data Processing Module.

  \item[\refstepcounter{acnum} \actheacnum \label{acInterface}:] \textbf{User Interface (UI) Design} - 
  Changes in analytical techniques along with advances in the machine learning space would
  introduce the need for new statistical models. These changes would be encapsulated in the
  Data Processing Module.

  \item[\refstepcounter{acnum} \actheacnum \label{acInput}:] \textbf{Input Data Formats} - 
  Currently, the system is expected to process data from Comma Separated Values (CSV) files only.
  In the future, however, modifications may have to be made to accommodate different file 
  formats (such as JavaScript Object Notation (JSON), Extensible Markup Language (XML) etc)
  which will be handled by the Data Ingestion Module without impacting other parts of the system.

  \item[\refstepcounter{acnum} \actheacnum \label{acSource}:] \textbf{Data Source Integration} - 
  New data sources such as third-party application programming interfaces (APIs), Internet of Things
  (IoT) devices may have to be added in the future. The Data Ingestion Module will have to be 
  redesigned to handle the integration of these new sources.

  \item[\refstepcounter{acnum} \actheacnum \label{acScaling}:] \textbf{Scaling Data Volume} - 
  As the number of experiments increases, the system may need to handle increasing data volumes
  as usage grows. This is addressed by the Data Storage Module which has been designed to support
  database scalability strategies.

  \item[\refstepcounter{acnum} \actheacnum \label{acRoles}:] \textbf{User Roles and Permissions} - 
  Future requirements may demand the addition of new user roles or changes to existing permissions.
  The Administration Module is designed to encapsulate these changes.

  \item[\refstepcounter{acnum} \actheacnum \label{acSchema}:] \textbf{Input Schema} - 
  With an increase in the number of diverse experiments, the schema for the data inputs may have to
  changed to support the addition or removal of new parameters. This is handled by the Data Ingestion
  Module.

  \item[\refstepcounter{acnum} \actheacnum \label{acNotifs}:] \textbf{Notification Rules} - 
  The conditions of triggering alerts or notifications may evolve, including but not limited to
  additional thresholds or new types of anomalies. These are handled by the Notifications Module
  without affecting other parts of the system.
  
  \item[\refstepcounter{acnum} \actheacnum \label{acMetrics}:] \textbf{Analytical Metrics} - 
  New metrics or Key Performance Indicators (KPIs) might be requested by stakeholders. This would
  involve adapting requirements by introducing new calculations or processing pipelines by modifying
  the Data Processing Module.
  
\end{description}

\subsection{Unlikely Changes} \label{SecUchange}

Unlikely changes are those that are fixed early in the design to simplify the system
and reduce complexity. These changes, if necessary, would have a significant impact on
multiple modules.

\begin{description}
  \item[\refstepcounter{ucnum} \uctheucnum \label{ucIO}:] \textbf{Input/Output Devices} - 
  The system is designed to support file-based inputs. Changes can include additional input
  and/or output methods such as direct hardware interaction, would require substantial
  redesign across multiple modules.
  
  \item[\refstepcounter{ucnum} \uctheucnum \label{ucSysArch}:] \textbf{Core System Architecture} -
  The underlying architectural decisions, such as the use of modular decomposition and separation
  of concerns, are not expected to change. Altering these decisions would necessitate a complete overhaul
  of the system.
  
  \item[\refstepcounter{ucnum} \uctheucnum \label{ucComms}:] \textbf{Communication Protocols} -
  The communication methods between modules such as function calls, API interactions etc are fixed. 
  Switching to a different communication protocol would impact the interfaces of all interacting modules.

  \item[\refstepcounter{ucnum} \uctheucnum \label{ucLanguage}:] \textbf{Programming Language} -
  The choice of programming languages is asssumed to be fixed for the project. A change would
  require rewriting most of the system.

  \item[\refstepcounter{ucnum} \uctheucnum \label{ucDatabase}:] \textbf{Database Type} -
  The choice of storage solution (relational versus NoSQL databases, for example) is assumed to remain
  fixed. Switching to a different type of database would require reworking the Data Storage
  Module and parts of the Data Processing Module.

\end{description}

\section{Module Hierarchy} \label{SecMH}

This section provides an overview of the module design for the Alkalytics system.
The modules are summarized in a hierarchy that follows the principle of information
hiding. Each module encapsulates specific secrets, ensuring changes are localized
and do not affect unrelated parts of the system. These modules are summarized in
a hierarchy decomposed by secrets in table \ref{TblMH}. This hierarchy represented
as a directed acyclic graph, shown in \ref{FigMH}, shows relationships betweem
higher-level and lower-level modules, with the leaf modules representing those that
will actually be implemented.

\begin{description}
\item [\refstepcounter{mnum} \mthemnum \label{mHH}:] Hardware-Hiding Module
\item [\refstepcounter{mnum} \mthemnum \label{mBH}:] Behaviour-Hiding Module
\item [\refstepcounter{mnum} \mthemnum \label{mIN}:] Interface Module 
\item [\refstepcounter{mnum} \mthemnum \label{mAD}:] Administration Module 
\item [\refstepcounter{mnum} \mthemnum \label{mDA}:] Data Acquisition Module 
\item [\refstepcounter{mnum} \mthemnum \label{mDS}:] Data Storage Module 
\item [\refstepcounter{mnum} \mthemnum \label{mDR}:] Data Retrieval Module 
\item [\refstepcounter{mnum} \mthemnum \label{mINP}:] Input Module 
\item [\refstepcounter{mnum} \mthemnum \label{mPR}:] Processing Module 
\item [\refstepcounter{mnum} \mthemnum \label{mOU}:] Output Module 
\item [\refstepcounter{mnum} \mthemnum \label{mUID}:] UI Design Module
\item [\refstepcounter{mnum} \mthemnum \label{mVI}:] Visualization Module
\item [\refstepcounter{mnum} \mthemnum \label{mUM}:] User Management Module 
\item [\refstepcounter{mnum} \mthemnum \label{mCM}:] Configuration Management Module
\item [\refstepcounter{mnum} \mthemnum \label{mDI}:] Data Ingestion Module
\item [\refstepcounter{mnum} \mthemnum \label{mDV}:] Data Validation Module 
\item [\refstepcounter{mnum} \mthemnum \label{mDT}:] Data Transformation Module 
\item [\refstepcounter{mnum} \mthemnum \label{mML}:] Machine Learning Module
\item [\refstepcounter{mnum} \mthemnum \label{mRE}:] Reporting Module 
\item [\refstepcounter{mnum} \mthemnum \label{mNO}:] Notification Module
\end{description}

\begin{table}[h!]
\centering
\begin{tabular}{p{0.3\textwidth} p{0.3\textwidth} p{0.35\textwidth}}
\toprule
\textbf{Level 1} & \textbf{Level 2} & \textbf{Level 3}\\
\midrule

{Hardware-Hiding Module} & ~ & ~ \\
& Data Acquisition Module & \\
& Data Storage Module & \\
& Data Retrieval Module & \\
\midrule

{Behaviour-Hiding Module} & Input Module & Data Ingestion Module\\
& & Data Validation Module\\
& Processing Module & Data Transformation Module\\
& & Machine Learning Module\\
& Output Module & Reporting Module\\
& & Notifications Module\\
\midrule

{Interface Module} & UI Design Module & \\
& Visualization Module & \\
\midrule

{Administration Module} & User Management Module & \\
& Configuration Management Module & \\
\bottomrule

\end{tabular}
\caption{Module Hierarchy}
\label{TblMH}
\end{table}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{Diagrams/DAG.png}
  \caption{A DAG representing the implemented module hierarchy of Alkalytics.}
  \label{fig:FigMH}
\end{figure}

It must be noted that the blue nodes shown in figure \ref{fig:FigMH} represent 
`container' modules that are non-leaf modules and encompass other leaf nodes.
The orange nodes represent leaf modules that will not be implemented for Revision
0 of Alkalytics and the green nodes represent leaf modules that will be implemented.

\section{Module Decomposition} \label{SecMD}

Modules are decomposed according to the principle of ``information hiding''
proposed by \citet{ParnasEtAl1984}. In this section, the \emph{Secrets} field acts as a brief
statement of the design decision hidden by the module. The \emph{Services} field specifies
\emph{what} the module will do without documenting \emph{how} to do it.\\
\newline
For each module, a suggestion for the implementing software is given under the 
\emph{Implemented By} title. If the entry is \emph{OS}, this means that the module is
provided by the operating system or by standard programming language libraries.
\emph{\progname{}} means the module will contain custom code and thus, will be implemented
by the software engineering team.\\
\newline
Descriptions for non-leaf modules or the modules that will not be implemented for Revision 0 of
Alkalytics have been provided below.

\subsection{Data Storage Module (\mref{mDS})}
\begin{description}
  \item[Secrets:] The data structure and algorithm used to store the received CSV files into the
  NoSQL database.
  \item[Services:] This module handles the storage of system data by interacting with
  a NoSQL database. It receives the transformed data from the Data Ingestion Module in a suitable
  format for storage in the database. This module also provides interfaces to query, retrieve, and
  update stored data.
  \item[Implemented By:] Software Engineering
  \item[Rationale:] This module abstracts the complexities of the NoSQL database
  structure, ensuring flexibility in storage design. It allows the system to 
  efficiently store the data in a schema-less NoSQL database. This ensures scalability and 
  adaptability to handle large datasets with varying structures.
\end{description}

\subsubsection{Uses}
This module is used by the Behavior-Hiding and Interface Module to interact
with the stored data. It provides mechanisms transform the CSV data, and
perform CRUD (Create, Read, Update, Delete) operations on the NoSQL database.

\subsubsection{Syntax}
\begin{description}
  \item[Exported Constants and Access Programs:]
  \item 
  \texttt{DB\_CONNECTION\_STRING}: The connection string for accessing the
    NoSQL database.
  \item
  \texttt{MAX\_BATCH\_SIZE}: The maximum number of rows to process and upload
  in a single batch.

  \begin{table}[h!]
    \centering
    \begin{tabular}{p{0.175\textwidth} p{0.175\textwidth} p{0.175\textwidth} p{0.4\textwidth}}
    \toprule
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
    \midrule
    
    \texttt{initializeDB} & - & Boolean & Throws \texttt{DatabaseInitializationError}
    if the database connection fails.\\
    \midrule
    
    \texttt{uploadData} & filePath(string) & Boolean & Throws \texttt{FileNotFoundError}
    if the file does not exist, or \texttt{DataTransformationError} if the Transformation
    fails.\\
    \midrule

    \texttt{queryData} & query(string) & Data (JSON) & Throws \texttt{QueryExecutionError}
    if the query is invalid.\\
    \midrule

    \texttt{updateData} & query(string), updates & Boolean & Throws \texttt{UpdateError}
    if the update fails.\\
    \bottomrule
    
    \end{tabular}
    \caption{Exported Access Programs for the Data Storage Module}
    \label{TblEAP_Storage}
  \end{table}
\end{description}

\subsubsection{Semantics}
\begin{description}
  \item[State Variables:]
  \item
  \texttt{database}: Represents the connection to the NoSQL database.
  \item
  \texttt{transformationRules}: Defines the set of rules for transforming CSV data to
  JSON format.
  \item[Environment Variables:]
  \item
  \begin{itemize}
    \item Interacts with the local file system to access CSV files.
  \end{itemize}
  \item 
  \begin{itemize}
    \item Connects to an external NoSQL database, MongoDB to be specific.
  \end{itemize}
  \item 

  \item[Assumptions:]
  \item
  \begin{itemize}
    \item Assumes the NoSQL database is accessible and the credentials are correct.
  \end{itemize}
  \item
  \begin{itemize}
    \item Assumes the received CSV files are well-formed and follow the expected schema.
  \end{itemize}
  \item 
  \begin{itemize}
    \item Assumes sufficient storage space is available in the database.
  \end{itemize}
  \item 

  \item[Access Routine Semantics:] 
  \item
  \texttt{initializeDB()}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Establishes a connection to the NoSQL database and validates
    the connection.
  \end{itemize}
  \item
  \begin{itemize}
    \item \textbf{Output}: Returns \texttt{True} if the database is successfully initialized.
    Throws a\\ \texttt{DatabaseInitializationError} otherwise.
  \end{itemize}
  \item 

  \texttt{uploadData(filePath:string)}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Reads the specified CSV file, transforms the contents into
    JSON format using \texttt{transformationRules}, and uploads the transformed data to
    the database in batches.
  \end{itemize}
  \item
  \begin{itemize}
    \item \textbf{Output}: Returns \texttt{True} if successful. Throws \texttt{FileNotFoundError}
    if the file does not exist or \texttt{DataTransformationError} if the transformation fails.
  \end{itemize}
  \item

  \texttt{queryData(query:string)}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Executes the specified query on the database and retrieves the
    corresponding data.
  \end{itemize}
  \item 
  \begin{itemize}
    \item \textbf{Output}: Returns the retrieved data in JSON format. Throws \texttt{QueryExecutionError}
    if the query is invalid or fails.
  \end{itemize}
  \item

  \texttt{updateData(query:string, updates)}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Applies the specified updates to the records matching the query
    in the database.
  \end{itemize}
  \item
  \begin{itemize}
    \item \textbf{Output}: Returns \texttt{True} if successful. Throws \texttt{UpdateError}
    if the operation fails.
  \end{itemize}
  \item

  \item[Local Function:] 
  \item
  \texttt{transformCSVToJSON(filePath:string)}:
  \item
  \begin{itemize}
    \item \textbf{Description}: Reads a CSV file and converts its rows into JSON objects based on
    \texttt{transformationRules}.
  \end{itemize}
  \item 
  \begin{itemize}
    \item \textbf{Output}: Returns a list of JSON objects or throws \texttt{DataTransformationError}
    if the transformation fails.
  \end{itemize}
  \item 
  \texttt{validateConnection()}:
  \item 
  \begin{itemize}
    \item \textbf{Description}: Checks the connection to the NoSQL database and returns \texttt{True}
    if valid.
  \end{itemize}
\end{description}

\subsection{Data Ingestion Module (\mref{mDI})}
\begin{description}
  \item[Secrets:] The data structure and algorithm used to ingest and preprocess data from
  the external source (CSV files) into the system.
  \item[Services:] This module is responsible for ingesting external data into the system.
  It interacts with various external data sources and converts incoming data into a 
  standardized format for further processing. The module ensures and facilitates seamless
  data flow into the system for subsequent operations.
  \item[Implemented By:] Software Engineering
  \item[Rationale:] The Data Ingestion Module abstracts the complexities of interacting with
  an external data source enabling the system to ingest data in CSV. By ensuring data Validation
  and transformation, the module guarantees data integrity and consistency before it is processed
  further. It ensures scalability, adaptability and flexibility in handling data from a different
  source while maintaining the quality of ingested data.
\end{description}

\subsubsection{Uses}
The Data Ingestion Module is used by the Data Processing Module to feed raw data into the system
for analysis and storage. It also supports integration with external services to retrieve and
preprocess data as needed. This module, in addition to the Data Validation Module ensures that all
incoming data is correctly formatted and validated before entering the system.

\subsubsection{Syntax}
\begin{description}
  \item[Exported Constants and Access Programs:] 
  \begin{table}[h!]
    \centering
    \begin{tabular}{p{0.25\textwidth} p{0.21\textwidth} p{0.22\textwidth} p{0.275\textwidth}}
    \toprule
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
    \midrule
    
    \texttt{initializeIngestion} & - & Boolean & Throws \texttt{IngestionError}
    if the process fails.\\
    \midrule
    
    \texttt{ingestData} & sourcePath(string) & Boolean & Throws \texttt{FileNotFoundError}
    if the file does not exist, or \texttt{DataTransformationError} if the Ingestion fails.\\
    \midrule

    \texttt{validateData} & data(Object) & Boolean & Throws \texttt{DataValidationError}
    if the data fails validation.\\
    \midrule

    \texttt{retrieveAPIData} & apiEndPoint(string) & Data (JSON) & Throws \texttt{APIRequestError}
    if the API request fails.\\
    \midrule

    \texttt{processData} & rawData(Object) & Object (Processed) & Throws \texttt{DataProcessingError}
    if the processing fails.\\
    \bottomrule
    
    \end{tabular}
    \caption{Exported Access Programs for the Data Ingestion Module}
    \label{TblEAP_Ingestion}
  \end{table}
\end{description}

\subsubsection{Semantics}
\begin{description}
  \item[State Variables:]
  \item
  \texttt{ingestionSource}: Represents the path or endpoint from which data is ingested.
  \item
  \texttt{dataFormat}: Defines the expected format of incoming data (CSV, in this case).

  \item[Environment Variables:]
  \item
  \begin{itemize}
    \item Interacts with the local file system to access CSV files.
  \end{itemize}
  \item 

  \item[Assumptions:]
  \item
  \begin{itemize}
    \item Assumes the external data sources are available and accessible.
  \end{itemize}
  \item
  \begin{itemize}
    \item Assumes the incoming data follows the expected format and schema.
  \end{itemize}
  \item 
  \begin{itemize}
    \item Assumes adequate network connectivity for external API requests.
  \end{itemize}
  \item
  \begin{itemize}
    \item Assumes sufficient memory and storage resources to handle large volumes of incoming data.
  \end{itemize}
  \item 

  \item[Access Routine Semantics:] 
  \item
  \texttt{initializeIngestion()}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Initialized the data ingestion process by configuring connections to
    external data sources.
  \end{itemize}
  \item
  \begin{itemize}
    \item \textbf{Output}: Returns \texttt{True} if initialization is successful. Throws an
    \\ \texttt{IngestionInitializationError} if initialization fails.
  \end{itemize}
  \item 

  \texttt{ingestData(sourcePath: string)}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Reads the specified data source, retrieves the raw data and prepares
    it for processing.
  \end{itemize}
  \item
  \begin{itemize}
    \item \textbf{Output}: Returns \texttt{True} if successful. Throws \texttt{FileNotFoundError}
    if the source path is invalid or does not exist, or \texttt{DataTransformationError} if the
    transformation process fails.
  \end{itemize}
  \item

  \texttt{retrieveAPIData(apiEndPoint: string)}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Sends a request to the specified API endpoints and retrieves data in JSON
    format.
  \end{itemize}
  \item 
  \begin{itemize}
    \item \textbf{Output}: Returns the retrieved data in JSON format. Throws \texttt{APIRequestError} if
    the request fails.
  \end{itemize}
  \item

  \texttt{processData(rawData: Object)}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Processes the raw data by applying transformation rules such as data
    normalization, mapping, filtering and more.
  \end{itemize}
  \item
  \begin{itemize}
    \item \textbf{Output}: Returns the processed data in the appropriate format. Throws \\
    \texttt{DataProcessingError} if the processing fails.
  \end{itemize}
  \item

  \item[Local Function:] 
  \item
  \texttt{transformRawDataToStandardFormat(sourcePath: string)}:
  \item
  \begin{itemize}
    \item \textbf{Description}: Reads the raw data from the specified source and applies the necessary Transformation
    rules and converts the data into a standardized format.
  \end{itemize}
  \item 
  \begin{itemize}
    \item \textbf{Output}: Returns the transformed data as a JSON object or throws \\
    \texttt{DataTransformationError} if the transformation fails.
  \end{itemize}
  \item 

  \texttt{validateSourceConnection()}:
  \item 
  \begin{itemize}
    \item \textbf{Description}: Checks the connection to the external data source and returns \texttt{True} if valid.
  \end{itemize}
  \item 
  \begin{itemize}
    \item \textbf{Output}: Returns \texttt{True} if the connection to the source is valid. Throws \\
   \texttt{SourceConnectionError} if the connection fails.
  \end{itemize}
\end{description}

\subsection{Data Validation Module (\mref{mDV})}
\begin{description}
  \item[Secrets:] The data structure is a finite-state machine designed to model transitions based on real-time 
  input data. The algorithm uses discrete math principles to validate parameters by comparing them against predefined
  thresholds and conditions derived from system requirements.
  \item[Services:] This module ensures valid data is provided for processing by validating input streams, flagging
  anomalies, and initiating corrective actions when necessary.
  \item[Implemented By:] OS and Software Engineering
  \item[Rationale:] Ensuring the integrity and realiability of input data is critical for accurate system operation.
  The FSM representation enables systematic handling of transitions, facilitating robust validation and error 
  detection mechanisms.
\end{description}

\subsubsection{Uses}
It is used to validate the sensor readings against operational thresholds while monitoring real-time 
data streams for deviations or inconsistencies. This module serves as a pre-processing step to ensure 
clean input data  for dependent modules.

\subsubsection{Syntax}
\begin{description}
  \item[Exported Constants:]
  \item 
  \lstinline{MAX_VOLTAGE}: Maximum allowable voltage (e.g., 10 V).
  \item
  \lstinline{MIN_VOLTAGE}: Minimum allowable voltage (e.g., 0 V).
  \item
  \lstinline{MAX_CURRENT}: Maximum allowable current (e.g., 1 A).
  \item
  \lstinline{MIN_CURRENT}: Minimum allowable current (e.g., 0 A).
  \item
  \lstinline{FLOW_RATE_THRESHOLD}: Acceptable range for flow rates (e.g., 0.1 to 60 L/min).
  \item
  \lstinline{PH_RANGE}: Acceptable pH range (e.g., 6.0 to 8.5).
  \item
  \item[Exported Access Programs:]
  \item
  \texttt{validate\_voltage(v:Real) \(\to\) Boolean}
  \item 
  \texttt{validate\_current(i:Real) \(\to\) Boolean}
  \item 
  \texttt{validate\_flow\_rate(f:Real) \(\to\) Boolean}
  \item
  \texttt{validate\_ph(v:Real) \(\to\) Boolean}
  \item
  \texttt{get\_error\_flags() \(\to\) Set}
\end{description}

\subsubsection{Semantics}
\begin{description}

  \item[State Variables:]
  \item
    \begin{itemize}
      \item \lstinline{voltage}: Current voltage reading.
    \end{itemize}
    \item
    \begin{itemize}
      \item \lstinline{current}: Current current reading.
    \end{itemize}
    \item 
    \begin{itemize}
      \item \lstinline{flow_rate}: Current flow rate reading.
    \end{itemize}
    \item 
    \begin{itemize}
      \item \lstinline{ph}: Current pH value.
    \end{itemize}
    \item 
    \begin{itemize}
      \item \lstinline{error_flags}: Set of flags indicating validation failures.
    \end{itemize}

  \item[Environment Variables:]
  \item
    \begin{itemize}
      \item Sensor input streams.
    \end{itemize}
    \item
    \begin{itemize}
      \item System clock for time-based validation.
    \end{itemize}

  \item[Assumptions:]
  \item
    \begin{itemize}
      \item Sensors provide data at consistent intervals.
    \end{itemize}
    \item
    \begin{itemize}
      \item Thresholds are pre-configured and static unless updated manually.
    \end{itemize}
    \item 
    \begin{itemize}
      \item Input data is numeric and within hardware limits.
    \end{itemize}

  \item[Access Routine Semantics:]
  \item
  \lstinline{validate_voltage(v:Real)}:
  \item
  \begin{itemize}
    \item If $MIN\_VOLTAGE \leq v \leq MAX\_VOLTAGE$, return True.
  \end{itemize}
  \item
  \begin{itemize}
    \item Else, add \lstinline{Voltage_Error} to \lstinline{error_flags} and return False.
  \end{itemize}
  \item 

  \lstinline{validate_current(i:Real)}:
  \item
  \begin{itemize}
    \item If $MIN\_CURRENT \leq i \leq MAX\_CURRENT$, return True.
  \end{itemize}
  \item
  \begin{itemize}
    \item Else, add \lstinline{Current_Error} to \lstinline{error_flags} and return False.
  \end{itemize}
  \item 

  \lstinline{validate_flow_rate(f: Real)}:
  \item
  \begin{itemize}
    \item If $FLOW\_RATE\_THRESHOLD[0] \leq f \leq FLOW\_RATE\_THRESHOLD[1]$, return True.
  \end{itemize}
  \item
  \begin{itemize}
    \item Else, add \lstinline{Flow_Rate_Error} to \lstinline{error_flags} and return False.
  \end{itemize}
  \item 

  \lstinline{validate_ph(p:Real)}:
  \item
  \begin{itemize}
    \item If $PH\_RANGE[0] \leq p \leq PH\_RANGE[1]$, return True.
  \end{itemize}
  \item
  \begin{itemize}
    \item Else, add \lstinline{PH_Error} to \lstinline{error_flags} and return False.
  \end{itemize}
  \item 

  \lstinline{get_error_flags()}:
  \item
  \begin{itemize}
    \item \textbf{Output:} Returns the current set of error flags.
  \end{itemize}

  \item[Local Function:]
  \item
  \lstinline{is_within_range(value: Real, range: Tuple[Real, Real])} $\to$ \lstinline{Boolean}:\\
  Checks if a given value lies within a specified range.
\end{description}

\subsection{Data Transformation Module (\mref{mDT})}
\begin{description}
  \item[Secrets:]The data structure and algorithm used to implement the virtual
    hardware.
  \item[Services:]Serves as a virtual hardware used by the rest of the
    system. This module provides the interface between the hardware and the
    software. So, the system can use it to display outputs or to accept inputs.
  \item[Implemented By:] OS
  \item[Rationale:] 
\end{description}

\subsubsection{Uses}

\subsubsection{Syntax}
\begin{description}
  \item[Exported Constants:] 
  \item[Exported Access Programs:] 
\end{description}

\subsubsection{Semantics}
\begin{description}
  \item[State Variables:]
  \item[Environment Variables:]  
  \item[Assumptions:] 
  \item[Access Routine Semantics:] 
  \item[Local Function:] 
\end{description}

\subsection{Machine Learning Module (\mref{mML})}
\begin{description}
  \item[Secrets:]The data structure and algorithm used to implement the virtual
    hardware.
  \item[Services:]Serves as a virtual hardware used by the rest of the
    system. This module provides the interface between the hardware and the
    software. So, the system can use it to display outputs or to accept inputs.
  \item[Implemented By:] OS
  \item[Rationale:] 
\end{description}

\subsubsection{Uses}

\subsubsection{Syntax}
\begin{description}
  \item[Exported Constants:] 
  \item[Exported Access Programs:] 
\end{description}

\subsubsection{Semantics}
\begin{description}
  \item[State Variables:]
  \item[Environment Variables:]  
  \item[Assumptions:] 
  \item[Access Routine Semantics:] 
  \item[Local Function:] 
\end{description}

\subsection{Reporting Module (\mref{mRE})}
\begin{description}
  \item[Secrets:]The data structure and algorithm used to implement the virtual
    hardware.
  \item[Services:]Serves as a virtual hardware used by the rest of the
    system. This module provides the interface between the hardware and the
    software. So, the system can use it to display outputs or to accept inputs.
  \item[Implemented By:] OS
  \item[Rationale:] 
\end{description}

\subsubsection{Uses}

\subsubsection{Syntax}
\begin{description}
  \item[Exported Constants:] 
  \item[Exported Access Programs:] 
\end{description}

\subsubsection{Semantics}
\begin{description}
  \item[State Variables:]
  \item[Environment Variables:]  
  \item[Assumptions:] 
  \item[Access Routine Semantics:] 
  \item[Local Function:] 
\end{description}

\subsection{Notifications Module (\mref{mNO})}
\begin{description}
  \item[Secrets:]The data structure and algorithm used to implement the virtual
    hardware.
  \item[Services:]Serves as a virtual hardware used by the rest of the
    system. This module provides the interface between the hardware and the
    software. So, the system can use it to display outputs or to accept inputs.
  \item[Implemented By:] OS
  \item[Rationale:] 
\end{description}

\subsubsection{Uses}

\subsubsection{Syntax}
\begin{description}
  \item[Exported Constants:] 
  \item[Exported Access Programs:] 
\end{description}

\subsubsection{Semantics}
\begin{description}
  \item[State Variables:]
  \item[Environment Variables:]  
  \item[Assumptions:] 
  \item[Access Routine Semantics:] 
  \item[Local Function:] 
\end{description}

\subsection{UI Design Module (\mref{mUID})}
\begin{description}
  \item[Secrets:] The design specifications and UI components that make  up the
  overall appearance and user experience of the system.
  \item[Services:] This module is responsible for the design and layout of the
  user interface.
  \item[Implemented By:] Software Engineering
  \item[Rationale:] The UI Design Module abstracts the presentation of data and
  interactions with the user.
\end{description}

\subsubsection{Uses}
This module is used by the Interface Module to manage the display of data and
user-related actions, ensuring that the design is consistent and offers a
positive user experience.

\subsubsection{Syntax}
\begin{description}
  \item[Exported Constants and Access Programs:]
  \item
  \begin{table}[h!]
    \centering
    \begin{tabular}{p{0.175\textwidth} p{0.175\textwidth} p{0.175\textwidth} p{0.4\textwidth}}
    \toprule
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
    \midrule
    \texttt{renderUI} & [components] & - & Throws \texttt{RenderError} if UI rendering fails.\\
    \midrule
    \texttt{updateUI} & component & - & Throws \texttt{UpdateError} if UI components cannot be updated.\\
    \bottomrule
    \end{tabular}
    \caption{Exported Access Programs for the UI Design Module}
    \label{TblEAP_UI}
  \end{table}
\end{description}

\subsubsection{Semantics}
\begin{description}
  \item[State Variables:] N/A
  
  \item[Environment Variables:]
  \item
  \begin{itemize}
    \item Interacts with the frontend framework (i.e., React) for rendering UI components.
  \end{itemize}
  
  \item[Assumptions:]
  \item
  \begin{itemize}
    \item Assumes the frontend framework is correctly set up for rendering UI components.
  \end{itemize}
  
  \item[Access Routine Semantics:] 
  \item \texttt{renderUI()}:
  \begin{itemize}
    \item \textbf{Transition}: Renders the components to display on the user interface.
    \item \textbf{Output}: The rendered interface. Throws \texttt{RenderError} if the UI rendering fails.
  \end{itemize}
  
  \item \texttt{updateUI()}:
  \begin{itemize}
    \item \textbf{Transition}: Updates specific components of the UI based on route changes or user interactions.
    \item \textbf{Output}: The updated UI. Throws \texttt{UpdateError} if updates fail.
  \end{itemize}
  
  \item[Local Function:] N/A
\end{description}

\subsection{Visualization Module (\mref{mVI})}
\begin{description}
  \item[Secrets:]The data structure and algorithm used to implement the virtual
    hardware.
  \item[Services:]Serves as a virtual hardware used by the rest of the
    system. This module provides the interface between the hardware and the
    software. So, the system can use it to display outputs or to accept inputs.
  \item[Implemented By:] OS
  \item[Rationale:] 
\end{description}

\subsubsection{Uses}

\subsubsection{Syntax}
\begin{description}
  \item[Exported Constants:] 
  \item[Exported Access Programs:] 
\end{description}

\subsubsection{Semantics}
\begin{description}
  \item[State Variables:]
  \item[Environment Variables:]  
  \item[Assumptions:] 
  \item[Access Routine Semantics:] 
  \item[Local Function:] 
\end{description}

\subsection{User Management Module (\mref{mUM})}
\begin{description}
  \item[Secrets:] The data structure and algorithm used to store and manage user
  credentials.
  \item[Services:]This module manages the creation, retrieval, and validation of
  user accounts. It interacts with the database to store user information and
  also provides interfaces for user authentication and Role-Based Access
  Control (RBAC).
  \item[Implemented By:] \progname{}
  \item[Rationale:] This module abstracts the management of user data, ensuring
  that sensitive information, such as passwords, is hashed and not stored in
  plain-text. It also enables the management of user access levels within the
  application. 
\end{description}

\subsubsection{Uses}
This module interacts with the Hardware-Hiding Module for user credential
storage and verification.

\subsubsection{Syntax}
\begin{description}
  \item[Exported Constants and Access Programs:]
  \item 
  \texttt{SESSION\_COOKIE}: The id of the session cookie used to maintain user sessions.
  
  \begin{table}[H]
    \centering
    \begin{tabular}{p{0.175\textwidth} p{0.175\textwidth} p{0.175\textwidth}
    p{0.4\textwidth}}
    \toprule
    \textbf{Name} & \textbf{In} & \textbf{Out} & \textbf{Exceptions}\\
    \midrule
    
    \texttt{createUser} & email(string), password(string), role(string) & dict &
    Throws \texttt{UserAlreadyExistsError} if the user already exists.\\
    \midrule
    
    \texttt{validateUser} & email(string), password(string) & dict & Throws
    \texttt{UserNotFoundError} if the user does not exist or
    \texttt{IncorrectPasswordError} if the password is incorrect.\\
    \midrule

    \texttt{getUserAndRole} & email(string) & dict & Throws
    \texttt{UserNotFoundError} if the user does not exist.\\
    \bottomrule

    \end{tabular}
    \caption{Exported Access Programs for the User Management Module}
    \label{TblEAP_UM}
  \end{table}
\end{description}

\subsubsection{Semantics}
\begin{description}
  \item[State Variables:]
  \item
  \texttt{usersCollection}: Represents the MongoDB collection storing user data.
  \item[Environment Variables:]
  \item N/A
  \item[Assumptions:]
  \item
  \begin{itemize}
    \item Assumes passwords are securely hashed before being stored.
  \end{itemize}
  \item
  \begin{itemize}
    \item Assumes emails are unique across the system.
  \end{itemize}

  \item[Access Routine Semantics:] 
  \item
  \texttt{createUser(email: string, password: string, role: string)}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Checks if a user with the given email already
    exists. If not, hashes the password, creates a new user, and stores the new
    user in the database.
  \end{itemize}
  \item
  \begin{itemize}
    \item \textbf{Output}: Returns a dictionary with user email and role if
    successful. Throws \\
    \texttt{UserAlreadyExistsError} if the user already exists.
  \end{itemize}

  \item
  \texttt{validateUser(email: string, password: string)}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Attempts to find user by email and compares hashed
    input password with the stored hash.
  \end{itemize}
  \item
  \begin{itemize}
    \item \textbf{Output}: Returns a dictionary with user email and role if the password is valid. Throws \texttt{UserNotFoundError} if the user doesn't exist or \texttt{IncorrectPasswordError} if the password is incorrect.
  \end{itemize}

  \item
  \texttt{getUserAndRole(email: string)}:
  \item
  \begin{itemize}
    \item \textbf{Transition}: Retrieves user with the specified email and
    corresponding role.
  \end{itemize}
  \item
  \begin{itemize}
    \item \textbf{Output}: Returns a dictionary with user email and role if the user exists. Throws \texttt{UserNotFoundError} if the user does not exist.
  \end{itemize}

  \item[Local Function:]
  \item
  \texttt{hashPassword(password: string)}:
  \item
  \begin{itemize}
    \item \textbf{Description}: Hashes the given password using \texttt{bcrypt}
    and a randomly-generated salt for secure storage.
  \end{itemize}
  \item 
  \begin{itemize}
    \item \textbf{Output}: Returns the hashed password string.
  \end{itemize}
\end{description}

\section{Traceability Matrix} \label{SecTM}

This section shows two traceability matrices: between the modules and the
requirements and between the modules and the anticipated changes.

% the table should use mref, the requirements should be named, use something
% like fref
\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.6\textwidth}}
\toprule
\textbf{Req.} & \textbf{Modules}\\
\midrule
R1 & \mref{mHH}, \mref{mInput}, \mref{mParams}, \mref{mControl}\\
R2 & \mref{mInput}, \mref{mParams}\\
R3 & \mref{mVerify}\\
R4 & \mref{mOutput}, \mref{mControl}\\
R5 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}, \mref{mSeqDS}, \mref{mSolver}, \mref{mPlot}\\
R6 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}, \mref{mSeqDS}, \mref{mSolver}, \mref{mPlot}\\
R7 & \mref{mOutput}, \mref{mEnergy}, \mref{mControl}, \mref{mSeqDS}, \mref{mPlot}\\
R8 & \mref{mOutput}, \mref{mEnergy}, \mref{mControl}, \mref{mSeqDS}, \mref{mPlot}\\
R9 & \mref{mVerifyOut}\\
R10 & \mref{mOutput}, \mref{mODEs}, \mref{mControl}\\
R11 & \mref{mOutput}, \mref{mODEs}, \mref{mEnergy}, \mref{mControl}\\
\bottomrule
\end{tabular}
\caption{Trace Between Requirements and Modules}
\label{TblRT}
\end{table}

\begin{table}[H]
\centering
\begin{tabular}{p{0.2\textwidth} p{0.1\textwidth}}
\toprule
\textbf{AC} & \textbf{Modules}\\
\midrule
\acref{acHardware} & \mref{mHH}\\
\acref{acProcessing} & \mref{mPR}\\
\acref{acInput} & \mref{mPR}\\
\acref{acInterface} & \mref{mIN}\\
\acref{acInput} & \mref{mIN}\\
\acref{acSource} & \mref{mIN}\\
\acref{acScaling} & \mref{mDS}\\
\acref{acRoles} & \mref{mAD}\\
\acref{acSchema} & \mref{mIN}\\
\acref{acNotifs} & \mref{mNO}\\
\acref{acMetrics} & \mref{mPR}\\
\bottomrule
\end{tabular}
\caption{Trace Between Anticipated Changes and Modules}
\label{TblACT}
\end{table}

\section{Use Hierarchy Between Modules} \label{SecUse}

In this section, the uses hierarchy between modules is
provided. \citet{Parnas1978} said of two programs A and B that A {\em uses} B if
correct execution of B may be necessary for A to complete the task described in
its specification. That is, A {\em uses} B if there exist situations in which
the correct functioning of A depends upon the availability of a correct
implementation of B.  Figure \ref{FigUH} illustrates the use relation between
the modules. It can be seen that the graph is a directed acyclic graph
(DAG). Each level of the hierarchy offers a testable and usable subset of the
system, and modules in the higher level of the hierarchy are essentially simpler
because they use modules from the lower levels.

\wss{The uses relation is not a data flow diagram.  In the code there will often
be an import statement in module A when it directly uses module B.  Module B
provides the services that module A needs.  The code for module A needs to be
able to see these services (hence the import statement).  Since the uses
relation is transitive, there is a use relation without an import, but the
arrows in the diagram typically correspond to the presence of import statement.}

\wss{If module A uses module B, the arrow is directed from A to B.}

\begin{figure}[H]
\centering
%\includegraphics[width=0.7\textwidth]{UsesHierarchy.png}
\caption{Use hierarchy among modules}
\label{FigUH}
\end{figure}

%\section*{References}

\section{User Interfaces}
The following figures encompass key design mock-ups of the application
interface, created using Figma. These mock-ups are merely wireframes and do not
represent the final interface design of the application.
\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{Figma/dashboard.pdf}
  \caption{The dashboard, or main home page of the application upon successful login.}
  \label{fig:FigUIDB}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{Figma/upload.pdf}
  \caption{The upload page for users to upload new experiment data files.}
  \label{fig:FigUIUP}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{Figma/table.pdf}
  \caption{The main view page for querying and modifying data.}
  \label{fig:FigUITB}
\end{figure}

\begin{figure}[htbp]
  \centering
  \includegraphics[width=\textwidth]{Figma/graphs.pdf}
  \caption{The main view page for generating and viewing visualizations of queried data.}
  \label{fig:FigUIG}
\end{figure}

\section{Timeline}

\wss{Schedule of tasks and who is responsible}

\wss{You can point to GitHub if this information is included there}

\bibliographystyle {plainnat}
\bibliography{../../../refs/References}

\newpage{}

\end{document}